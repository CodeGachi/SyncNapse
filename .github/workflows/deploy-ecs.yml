name: Deploy to ECS

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
  workflow_dispatch:  # Manual trigger

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

jobs:
  # ============================================
  # Prepare: Sync env & apply DB schema
  # ============================================
  prepare:
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.vars.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Cache bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Set output variables
        id: vars
        run: echo "tag=sha-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

      - name: Sync Environment & Apply DB Schema
        env:
          GITHUB_TOKEN: ${{ secrets.ENV_REPO_PAT }}
          ENV_REPO_URL: https://x-access-token:${{ secrets.ENV_REPO_PAT }}@github.com/CodeGachi/.env.git
          DATABASE_URL: postgresql://${{ secrets.PROD_DB_USER }}:${{ secrets.PROD_DB_PASSWORD }}@${{ secrets.PROD_DB_HOST }}:${{ secrets.PROD_DB_PORT }}/${{ secrets.PROD_DB_NAME }}?schema=public
        run: |
          # Install and sync env
          bun install --ignore-scripts
          bun scripts/sync-env-from-repo.mjs prod
          cp .env.prod .env && cp .env frontend/.env
          
          # Apply DB schema (uses backend's prisma)
          cd backend && bun install --frozen-lockfile
          bunx prisma db push --skip-generate --accept-data-loss
          echo "âœ… Prepare complete"

      - name: Upload env artifact
        uses: actions/upload-artifact@v4
        with:
          name: env-files
          path: |
            .env
            frontend/.env
          retention-days: 1

  # ============================================
  # Build Frontend (parallel)
  # ============================================
  build-frontend:
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.build.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - name: Download env artifact
        uses: actions/download-artifact@v4
        with:
          name: env-files
          path: .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: aws-actions/amazon-ecr-login@v2

      - uses: docker/setup-buildx-action@v3

      - name: Build and push Frontend
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/${{ secrets.ECR_REPO_FRONTEND }}:${{ needs.prepare.outputs.tag }}
            ${{ env.ECR_REGISTRY }}/${{ secrets.ECR_REPO_FRONTEND }}:latest
          cache-from: |
            type=gha,scope=frontend
            type=registry,ref=${{ env.ECR_REGISTRY }}/${{ secrets.ECR_REPO_FRONTEND }}:cache
          cache-to: |
            type=gha,scope=frontend,mode=max
            type=registry,ref=${{ env.ECR_REGISTRY }}/${{ secrets.ECR_REPO_FRONTEND }}:cache,mode=max
          provenance: false

      - run: echo "image=${{ env.ECR_REGISTRY }}/${{ secrets.ECR_REPO_FRONTEND }}:${{ needs.prepare.outputs.tag }}" >> $GITHUB_OUTPUT
        id: output

  # ============================================
  # Build Backend (parallel)
  # ============================================
  build-backend:
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.build.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: aws-actions/amazon-ecr-login@v2

      - uses: docker/setup-buildx-action@v3

      - name: Build and push Backend
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/${{ secrets.ECR_REPO_BACKEND }}:${{ needs.prepare.outputs.tag }}
            ${{ env.ECR_REGISTRY }}/${{ secrets.ECR_REPO_BACKEND }}:latest
          cache-from: |
            type=gha,scope=backend
            type=registry,ref=${{ env.ECR_REGISTRY }}/${{ secrets.ECR_REPO_BACKEND }}:cache
          cache-to: |
            type=gha,scope=backend,mode=max
            type=registry,ref=${{ env.ECR_REGISTRY }}/${{ secrets.ECR_REPO_BACKEND }}:cache,mode=max
          provenance: false

      - run: echo "image=${{ env.ECR_REGISTRY }}/${{ secrets.ECR_REPO_BACKEND }}:${{ needs.prepare.outputs.tag }}" >> $GITHUB_OUTPUT
        id: output

  # ============================================
  # Deploy to ECS
  # ============================================
  deploy:
    needs: [prepare, build-frontend, build-backend]
    runs-on: ubuntu-latest
    env:
      ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
      ECS_SERVICE_FRONTEND: ${{ secrets.ECS_SERVICE_FRONTEND }}
      ECS_SERVICE_BACKEND: ${{ secrets.ECS_SERVICE_BACKEND }}
      ECS_TASK_DEFINITION_FRONTEND: ${{ secrets.ECS_TASK_DEFINITION_FRONTEND }}
      ECS_TASK_DEFINITION_BACKEND: ${{ secrets.ECS_TASK_DEFINITION_BACKEND }}
    steps:
      - uses: actions/checkout@v4

      - name: Download env artifact
        uses: actions/download-artifact@v4
        with:
          name: env-files
          path: .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Prepare Environment Variables JSON
        run: |
          node -e '
            const fs = require("fs");
            const env = fs.readFileSync(".env", "utf8");
            const json = env.split("\n")
              .filter(line => line && !line.startsWith("#"))
              .map(line => {
                const [key, ...rest] = line.split("=");
                if (!key || !rest.length) return null;
                return { name: key.trim(), value: rest.join("=").trim() };
              })
              .filter(Boolean);
            console.log(JSON.stringify(json));
          ' > env.json

      - name: Update Task Definitions & Deploy
        run: |
          TAG="${{ needs.prepare.outputs.tag }}"
          
          # Update Frontend Task Definition
          aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION_FRONTEND \
            --query 'taskDefinition' --output json > /tmp/td-fe.json
          
          jq --arg IMG "$ECR_REGISTRY/${{ secrets.ECR_REPO_FRONTEND }}:$TAG" \
             --slurpfile ENV env.json \
            '.containerDefinitions[0].image = $IMG | .containerDefinitions[0].environment = $ENV[0] |
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            /tmp/td-fe.json > /tmp/new-td-fe.json
          
          FE_ARN=$(aws ecs register-task-definition --cli-input-json file:///tmp/new-td-fe.json \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          
          # Update Backend Task Definition
          aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION_BACKEND \
            --query 'taskDefinition' --output json > /tmp/td-be.json
          
          jq --arg IMG "$ECR_REGISTRY/${{ secrets.ECR_REPO_BACKEND }}:$TAG" \
             --slurpfile ENV env.json \
            '.containerDefinitions[0].image = $IMG | .containerDefinitions[0].environment = $ENV[0] |
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            /tmp/td-be.json > /tmp/new-td-be.json
          
          BE_ARN=$(aws ecs register-task-definition --cli-input-json file:///tmp/new-td-be.json \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          
          # Deploy both services in parallel
          aws ecs update-service --cluster "$ECS_CLUSTER" --service "$ECS_SERVICE_FRONTEND" \
            --task-definition "$FE_ARN" --force-new-deployment --no-cli-pager > /dev/null &
          aws ecs update-service --cluster "$ECS_CLUSTER" --service "$ECS_SERVICE_BACKEND" \
            --task-definition "$BE_ARN" --force-new-deployment --no-cli-pager > /dev/null &
          wait
          
          echo "ðŸš€ Deployment complete!"
          echo "  Tag: $TAG"
          echo "  Frontend: $ECS_SERVICE_FRONTEND"
          echo "  Backend: $ECS_SERVICE_BACKEND"
