generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(cuid())
  email         String   @db.Citext @unique
  displayName   String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?
  folders       Folder[]
  bookmark      Bookmark[]
  authProvider  String   // e.g., cognito, credentials, oauth
  role          String   // e.g., user, admin, educator, student
  // Back-relations
  // Ink back-relations
  inkLayersCreated       InkLayer[]   @relation("InkLayerCreatedBy")
  inkStrokesCreated      InkStroke[]  @relation("InkStrokeCreatedBy")
  // Uploads and Q&A back-relations
  uploads                Upload[]     @relation("UserUploads")
  questionsAsked         Question[]   @relation("UserAskedQuestions")
  answersAuthored        Answer[]     @relation("UserAnsweredAnswers")
  auditLogs              AuditLog[]
  // Auth-related back-relations
  refreshTokens          RefreshToken[]
  // LiveSession-related back-relations
  sessionsCreated        LiveSession[] @relation("SessionPresenter")
  sessionMemberships     SessionMember[]
  typingSections         TypingSection[] @relation("UserTypingSections")
  // Device and transcription back-relations
  trustedDevices         TrustedDevice[]
  transcriptionSessions  TranscriptionSession[]
}

model Folder {
  id        String   @id @default(cuid())
  userId    String
  name      String
  parentId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
  user      User     @relation(fields: [userId], references: [id])
  // Hierarchical self relation
  parent    Folder?  @relation("FolderToChildren", fields: [parentId], references: [id])
  children  Folder[] @relation("FolderToChildren")
  // Many-to-many with LectureNote via explicit join
  notesLink FolderLectureNote[]
  @@index([userId])
  @@index([parentId])
}

model LectureNote {
  id             String   @id @default(cuid())
  title          String
  type           String   @default("student") // Note type: 'student' or 'educator'
  sourceFileUrl  String?  // original lecture material file storage URL
  audioFileUrl   String?  // recorded audio file storage URL
  sourceBlobId   String?  // optional: file stored in DB (not recommended for production)
  audioBlobId    String?  // optional: audio stored in DB (not recommended for production)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  deletedAt      DateTime?
  // Many-to-many with Folder via explicit join
  foldersLink    FolderLectureNote[]
  transcript     TranscriptSegment[]
  translations   TranslationSegment[]
  typingSections TypingSection[]
  mediaLinks     MediaLink[]
  // Time-aligned chunks
  chunks         MediaChunk[]
  // Structured assets and user artifacts
  materialPages  MaterialPage[]
  audioRecordings AudioRecording[]
  inkLayers      InkLayer[]
  bookmark       Bookmark[]
  // LiveSession and SectionSync relations
  liveSessions   LiveSession[]
  sectionSyncs   SectionSync[]
  questions      Question[]
  // FileBlob relations
  sourceBlob     FileBlob? @relation("LectureNoteSourceBlob", fields: [sourceBlobId], references: [id])
  audioBlob      FileBlob? @relation("LectureNoteAudioBlob", fields: [audioBlobId], references: [id])
  // File attachments (MinIO/S3 storage)
  files          File[]
  // Page-specific note contents (DEPRECATED)
  pageContents   PageContent[] @relation("PageContentToNote")
  // Note-level content (NEW)
  noteContent    NoteContent? @relation("NoteContentToNote")
  
  @@index([sourceBlobId])
  @@index([audioBlobId])
}

// File attachments for LectureNote (stored in MinIO/S3)
model File {
  id          String   @id @default(cuid())
  noteId      String
  fileName    String
  fileType    String   // MIME type
  fileSize    Int      // Size in bytes
  storageUrl  String   // MinIO/S3 URL or path
  storageKey  String   // MinIO object key for deletion
  uploadedAt  DateTime @default(now())
  deletedAt   DateTime?

  note        LectureNote @relation(fields: [noteId], references: [id], onDelete: Cascade)

  @@index([noteId])
  @@index([storageKey])
}

// ============================================================================
// ============================================================================
// Transcription (녹음 및 자막) - 통합 버전
// ============================================================================
// WhisperCpp WASM 기반 로컬 실시간 자막 생성 및 백엔드 저장
// - 자막과 오디오 chunk 링킹
// - MinIO에 오디오 저장, PostgreSQL에 메타데이터 저장
// - 재생 시 자막-오디오 동기화
// ============================================================================

// Explicit join table mapping for Folder <-> LectureNote
model FolderLectureNote {
  folderId String
  noteId   String

  folder Folder @relation(fields: [folderId], references: [id])
  note   LectureNote @relation(fields: [noteId], references: [id])

  @@id([folderId, noteId])
  @@map("FolderLectureNote")
}

model TranscriptSegment {
  id            String   @id @default(cuid())
  noteId        String
  chunkId       String?
  // timestamps in seconds with decimal precision
  startSec      Decimal  @db.Decimal(7, 2)
  endSec        Decimal  @db.Decimal(7, 2)
  text          String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  note          LectureNote @relation(fields: [noteId], references: [id])
  chunk         MediaChunk? @relation(fields: [chunkId], references: [id])
  // links to other entities at that timestamp
  links         MediaLink[]
  @@index([noteId, startSec])
  @@index([chunkId])
}

model TranslationSegment {
  id            String   @id @default(cuid())
  noteId        String
  chunkId       String?
  sourceLang    String
  targetLang    String
  startSec      Decimal  @db.Decimal(7, 2)
  endSec        Decimal  @db.Decimal(7, 2)
  text          String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  note          LectureNote @relation(fields: [noteId], references: [id])
  chunk         MediaChunk? @relation(fields: [chunkId], references: [id])
  links         MediaLink[]
  @@index([noteId, targetLang, startSec])
  @@index([chunkId])
}

model TypingSection {
  id            String   @id @default(cuid())
  noteId        String
  chunkId       String?
  userId        String   // Who created this typing section (student/presenter)
  sessionId     String?  // Optional: linked to a live session
  // a named section of typed notes that can map to a time range
  title         String
  content       String
  startSec      Decimal? @db.Decimal(7, 2)
  endSec        Decimal? @db.Decimal(7, 2)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  note          LectureNote @relation(fields: [noteId], references: [id])
  chunk         MediaChunk? @relation(fields: [chunkId], references: [id])
  user          User @relation("UserTypingSections", fields: [userId], references: [id])
  session       LiveSession? @relation("SessionTypingSections", fields: [sessionId], references: [id])
  links         MediaLink[]
  @@index([noteId, startSec])
  @@index([chunkId])
  @@index([userId])
  @@index([sessionId])
}

// A generic link that associates a time range to resources (file page, transcript, translation, typing)
model MediaLink {
  id                 String   @id @default(cuid())
  noteId             String
  // the canonical timestamp range this link represents
  startSec           Decimal @db.Decimal(7, 2)
  endSec             Decimal @db.Decimal(7, 2)
  // link type: 'file_page', 'transcript', 'translation', 'typing'
  linkType           String
  // detailed reference: page number for file, foreign keys for segments/sections
  filePageNumber     Int?
  transcriptId       String?
  translationId      String?
  typingSectionId    String?
  // extended references: material page and audio slice
  materialPageId     String?
  audioSliceId       String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  note               LectureNote @relation(fields: [noteId], references: [id])
  transcriptSegment  TranscriptSegment? @relation(fields: [transcriptId], references: [id])
  translationSegment TranslationSegment? @relation(fields: [translationId], references: [id])
  typingSection      TypingSection? @relation(fields: [typingSectionId], references: [id])
  materialPage       MaterialPage? @relation(fields: [materialPageId], references: [id])
  audioSlice         AudioSlice? @relation(fields: [audioSliceId], references: [id])
  @@index([noteId, startSec])
}

// Material pages belong to a note and represent per-page assets
model MaterialPage {
  id         String   @id @default(cuid())
  noteId     String
  pageNumber Int
  pageUrl    String?
  pageBlobId String?  // optional: page image stored in DB (not recommended for production)
  // canonicalization
  pageHash   String?   // sha256 or stable content hash
  canonicalPageId String?
  viewTransform Json?  // normalized transform to render canonical into this page viewport
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  note       LectureNote @relation(fields: [noteId], references: [id])
  links      MediaLink[]
  canonical  CanonicalPage? @relation(fields: [canonicalPageId], references: [id])
  inkLayers  InkLayer[]
  questions  Question[]
  pageBlob   FileBlob? @relation("MaterialPageBlob", fields: [pageBlobId], references: [id])
  pageContent PageContent? // Typed note content for this page
  @@unique([noteId, pageNumber])
  @@index([canonicalPageId])
  @@index([pageBlobId])
}

// Page-specific note content (blocks) - DEPRECATED, use NoteContent instead
model PageContent {
  id                String   @id @default(cuid())
  noteId            String
  pageId            String   @unique
  pageNumber        Int
  blocks            Json     // Array of note blocks with content, type, indent, etc.
  storageKey        String?  // MinIO storage key for JSON backup
  version           Int      @default(1)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  note              LectureNote @relation("PageContentToNote", fields: [noteId], references: [id])
  page              MaterialPage @relation(fields: [pageId], references: [id])
  @@unique([noteId, pageNumber])
  @@index([noteId, pageNumber])
}

// Note-level content (all pages in a single document)
model NoteContent {
  id         String   @id @default(cuid())
  noteId     String   @unique
  content    Json     // { pages: { "1": { blocks: [...] }, "2": { blocks: [...] } } }
  version    Int      @default(1)
  storageKey String?  // MinIO storage key for JSON backup (typing/note_content.json)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  note       LectureNote @relation("NoteContentToNote", fields: [noteId], references: [id])
  @@index([noteId])
}

// Audio recordings attached to a note (file-level)
model AudioRecording {
  id           String   @id @default(cuid())
  noteId       String
  fileUrl      String
  fileBlobId   String?  // optional: audio file stored in DB (not recommended for production)
  durationSec  Decimal? @db.Decimal(7, 2)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  note         LectureNote @relation(fields: [noteId], references: [id])
  slices       AudioSlice[]
  fileBlob     FileBlob? @relation("AudioRecordingBlob", fields: [fileBlobId], references: [id])
  @@index([noteId])
  @@index([fileBlobId])
}

// Sliced audio segments with optional file offset for alignment
model AudioSlice {
  id             String   @id @default(cuid())
  recordingId    String
  chunkId        String?
  startSec       Decimal @db.Decimal(7, 2)
  endSec         Decimal @db.Decimal(7, 2)
  fileOffsetSec  Decimal? @db.Decimal(7, 2)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  recording      AudioRecording @relation(fields: [recordingId], references: [id])
  chunk          MediaChunk? @relation(fields: [chunkId], references: [id])
  links          MediaLink[]
  @@index([recordingId, startSec])
  @@index([chunkId])
}

model Bookmark {
  id             String   @id @default(cuid())
  noteId         String
  userId         String
  startSec       Decimal @db.Decimal(7, 2)
  tag            String?
  comment        String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  note           LectureNote @relation(fields: [noteId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  user           User @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  @@index([noteId, startSec])
  @@index([userId])
  @@unique([userId, noteId, startSec])
}

// === Live Session & Collaboration ===

// Live session for real-time collaboration
model LiveSession {
  id               String   @id @default(cuid())
  noteId           String
  presenterId      String   // Educator/instructor who created the session
  title            String?
  liveblocksRoomId String?  // Optional: Liveblocks room identifier
  isActive         Boolean  @default(true)
  startedAt        DateTime @default(now())
  endedAt          DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  note             LectureNote @relation(fields: [noteId], references: [id])
  presenter        User @relation("SessionPresenter", fields: [presenterId], references: [id])
  members          SessionMember[]
  invites          SessionInvite[]
  sectionSyncs     SectionSync[]
  typingSections   TypingSection[] @relation("SessionTypingSections")

  @@index([noteId])
  @@index([presenterId])
  @@index([isActive])
}

// Session invite tokens for joining
model SessionInvite {
  id         String   @id @default(cuid())
  sessionId  String
  token      String   @unique  // Unique invite token
  expiresAt  DateTime
  maxUses    Int?     // null = unlimited
  usedCount  Int      @default(0)
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())

  session    LiveSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([sessionId])
  @@index([expiresAt])
}

// Session members (participants)
model SessionMember {
  id          String   @id @default(cuid())
  sessionId   String
  userId      String
  role        String   // 'presenter' | 'listener'
  displayName String?  // Optional display name for anonymous users
  joinedAt    DateTime @default(now())
  leftAt      DateTime?

  session     LiveSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user        User @relation(fields: [userId], references: [id])

  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([userId])
}

// Section sync mapping for shared materials
model SectionSync {
  id             String   @id @default(cuid())
  sessionId      String
  noteId         String
  mode           String   // 'LINK' | 'COPY'
  excludeTyping  Boolean  @default(true) // Exclude typing sections from shared content
  startSec       Decimal? @db.Decimal(7, 2)
  endSec         Decimal? @db.Decimal(7, 2)
  pageNumber     Int?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  session        LiveSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  note           LectureNote @relation(fields: [noteId], references: [id])

  @@index([sessionId])
  @@index([noteId])
}

// Time-aligned chunk to group transcript/translation/typing and audio slices
model MediaChunk {
  id          String   @id @default(cuid())
  noteId      String
  startSec    Decimal @db.Decimal(7, 2)
  endSec      Decimal @db.Decimal(7, 2)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  note        LectureNote @relation(fields: [noteId], references: [id])
  transcripts TranscriptSegment[]
  translations TranslationSegment[]
  typings     TypingSection[]
  slices      AudioSlice[]
  inkLayers   InkLayer[]

  @@index([noteId, startSec])
}

// Canonicalized page deduplication unit
model CanonicalPage {
  id          String   @id @default(cuid())
  contentHash String   @unique // sha256 of normalized page bitmap/vector
  sourceType  String             // pdf|image|other
  renderKey   String?            // storage key for canonical render (e.g., PNG)
  width       Int
  height      Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  materialPages MaterialPage[]
  inkLayers     InkLayer[]
}

// Ink grouping per chunk/page with style and ownership
model InkLayer {
  id               String   @id @default(cuid())
  noteId           String
  chunkId          String?
  canonicalPageId  String?
  materialPageId   String?
  title            String?
  color            String?  // default stroke color
  opacity          Float?   // 0..1
  blendMode        String?  // normal/multiply/... (client-defined)
  zIndex           Int?     // layer order
  createdByUserId  String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  note        LectureNote @relation(fields: [noteId], references: [id])
  chunk       MediaChunk? @relation(fields: [chunkId], references: [id])
  canonical   CanonicalPage? @relation(fields: [canonicalPageId], references: [id])
  material    MaterialPage? @relation(fields: [materialPageId], references: [id])
  createdBy   User @relation("InkLayerCreatedBy", fields: [createdByUserId], references: [id])
  strokes     InkStroke[]

  @@index([noteId, chunkId])
  @@index([canonicalPageId])
  @@index([materialPageId])
}

// Individual stroke data (vector points), large payload -> JSON
model InkStroke {
  id          String   @id @default(cuid())
  layerId     String
  tool        String?     // pen|highlighter|eraser|shape
  color       String?
  thickness   Float?
  // raw points array with x,y,t,pressure; client-normalized to canonical/page space
  points      Json
  // optional precomputed bounding box {x,y,w,h}
  bbox        Json?
  createdById String
  createdAt   DateTime @default(now())

  layer       InkLayer @relation(fields: [layerId], references: [id])
  createdBy   User @relation("InkStrokeCreatedBy", fields: [createdById], references: [id])

  @@index([layerId])
}

// === Chunked upload schema ===

enum UploadStatus {
  PENDING
  RECEIVING
  ASSEMBLING
  COMPLETED
  FAILED
  CANCELLED
}

model Upload {
  id             String        @id @default(cuid())
  userId         String?
  fileName       String
  mimeType       String?
  totalSizeBytes Int?
  totalChunks    Int
  receivedChunks Int           @default(0)
  status         UploadStatus  @default(PENDING)
  checksumSha256 String?
  storageKey     String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  completedAt    DateTime?

  chunks         UploadChunk[]
  user           User?         @relation("UserUploads", fields: [userId], references: [id])

  @@index([userId])
}

model UploadChunk {
  id         String   @id @default(cuid())
  uploadId   String
  index      Int
  sizeBytes  Int?
  checksum   String?
  receivedAt DateTime @default(now())

  upload     Upload   @relation(fields: [uploadId], references: [id])

  @@unique([uploadId, index])
  @@index([uploadId])
}

// === Q&A schema with slide (MaterialPage) reference ===

model Question {
  id              String      @id @default(cuid())
  askedByUserId   String
  noteId          String?
  materialPageId  String?
  startSec        Decimal?    @db.Decimal(7, 2)
  text            String
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  askedBy         User          @relation("UserAskedQuestions", fields: [askedByUserId], references: [id])
  note            LectureNote?  @relation(fields: [noteId], references: [id])
  materialPage    MaterialPage? @relation(fields: [materialPageId], references: [id])
  answers         Answer[]

  @@index([askedByUserId])
  @@index([noteId, startSec])
}

model Answer {
  id             String   @id @default(cuid())
  questionId     String
  answeredByUserId String
  text           String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  question       Question @relation(fields: [questionId], references: [id])
  answeredBy     User     @relation("UserAnsweredAnswers", fields: [answeredByUserId], references: [id])

  @@index([questionId])
  @@index([answeredByUserId])
}

// === Audit Log ===
model AuditLog {
  id         String   @id @default(cuid())
  at         DateTime @default(now())
  userId     String?
  method     String?
  path       String?
  status     Int?
  ip         String?
  userAgent  String?
  requestId  String?
  action     String?
  resourceId String?
  payload    Json?

  user       User?    @relation(fields: [userId], references: [id])

  @@index([userId, at])
}

// === Auth Enhancement Tables ===

// Refresh Token for JWT token renewal
model RefreshToken {
  id           String   @id @default(cuid())
  userId       String
  token        String   @unique  // hashed refresh token
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  usedAt       DateTime?
  replacedBy   String?  // new refresh token id when rotated
  revokedAt    DateTime?
  revokedReason String?  // logout, compromised, expired
  ipAddress    String?
  userAgent    String?

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

// OAuth state for CSRF protection
model OAuthState {
  id          String   @id @default(cuid())
  state       String   @unique
  provider    String
  redirectUrl String?
  codeVerifier String? // PKCE verifier
  createdAt   DateTime @default(now())
  expiresAt   DateTime
  usedAt      DateTime?

  @@index([state])
  @@index([expiresAt])
}

// JWT Blacklist for logout
model JwtBlacklist {
  id        String   @id @default(cuid())
  jti       String   @unique  // JWT ID (unique token identifier)
  expiresAt DateTime
  createdAt DateTime @default(now())
  reason    String?  // logout, security

  @@index([jti])
  @@index([expiresAt])
}

// === File Blob Storage (⚠️ NOT recommended for production) ===
// This stores files directly in PostgreSQL using BYTEA
// Consider using S3, GCS, or MinIO for production systems
model FileBlob {
  id         String   @id @default(cuid())
  fileName   String
  mimeType   String?
  sizeBytes  Int
  data       Bytes    // Binary data stored in BYTEA (PostgreSQL limit: 1GB)
  checksum   String?  // SHA256 or other hash for integrity verification
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  // Back-relations to entities using this blob
  lectureNotesAsSource  LectureNote[] @relation("LectureNoteSourceBlob")
  lectureNotesAsAudio   LectureNote[] @relation("LectureNoteAudioBlob")
  audioRecordings       AudioRecording[] @relation("AudioRecordingBlob")
  materialPages         MaterialPage[] @relation("MaterialPageBlob")
  
  @@index([fileName])
  @@index([mimeType])
  @@index([createdAt])
}

// === Trusted Devices for P2P Communication ===
// Stores registered devices for WebRTC P2P audio streaming
model TrustedDevice {
  id            String   @id @default(cuid())
  userId        String
  deviceName    String   // User-friendly name: "iPhone 13", "MacBook Pro"
  deviceType    String   // mobile, desktop, tablet
  fingerprint   String   @unique // Unique device identifier (browser fingerprint or UUID)
  publicKey     String?  // Optional: for future E2E encryption
  lastSeenAt    DateTime @default(now())
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([fingerprint])
}

// === Transcription Sessions ===
// Web Speech API 기반 실시간 자막 생성 및 백엔드 저장
model TranscriptionSession {
  id              String   @id @default(cuid())
  userId          String
  title           String   @default("Untitled Session")
  noteId          String?  // Optional: link to LectureNote
  startTime       Decimal  @default(0) @db.Decimal(10, 3) // Session start timestamp (relative to recording start, in seconds)
  endTime         Decimal? @db.Decimal(10, 3) // Session end timestamp (relative to recording start, in seconds)
  duration        Decimal  @default(0) @db.Decimal(10, 3) // Total duration in seconds
  status          String   @default("recording") // recording, completed, processing
  fullAudioUrl    String?  // Full audio file URL (MinIO)
  fullAudioKey    String?  // Full audio file storage key (MinIO)
  fullAudioSize   Int?     // Full audio file size in bytes
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  deletedAt       DateTime?

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  audioChunks     AudioChunk[]
  segments        TranscriptionSegment[]

  @@index([userId])
  @@index([createdAt])
  @@index([status])
}

// === Audio Chunks ===
// 오디오 chunk 저장 (MinIO에 실제 파일, DB에 메타데이터)
model AudioChunk {
  id              String   @id @default(cuid())
  sessionId       String
  chunkIndex      Int      // Sequential index (0부터 시작)
  startTime       Decimal  @db.Decimal(10, 3) // Start time in seconds (millisecond precision)
  endTime         Decimal  @db.Decimal(10, 3) // End time in seconds
  duration        Decimal  @db.Decimal(10, 3) // Duration in seconds
  sampleRate      Int      @default(16000)
  storageUrl      String   // MinIO URL
  storageKey      String   // MinIO object key
  fileSize        Int      @default(0) // Size in bytes
  createdAt       DateTime @default(now())

  session         TranscriptionSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  @@unique([sessionId, chunkIndex])
  @@index([sessionId])
  @@index([storageKey])
}

// === Transcription Segments ===
// 자막 세그먼트 (문장 단위)
model TranscriptionSegment {
  id              String   @id @default(cuid())
  sessionId       String
  text            String   @db.Text
  startTime       Decimal  @db.Decimal(10, 3) // Start time in seconds (millisecond precision)
  endTime         Decimal  @db.Decimal(10, 3) // End time in seconds
  confidence      Decimal  @default(0) @db.Decimal(5, 4) // 0.0 to 1.0
  isPartial       Boolean  @default(false) // true for streaming partial results
  language        String   @default("ko")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  session         TranscriptionSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  words           TranscriptionWord[]

  @@index([sessionId, startTime])
  @@index([sessionId, isPartial])
}

// === Transcription Words ===
// 단어 레벨 타임스탬프 (자막 내부의 각 단어)
model TranscriptionWord {
  id              String   @id @default(cuid())
  segmentId       String
  word            String   // 단어 텍스트
  startTime       Decimal  @db.Decimal(10, 3) // Word start time in seconds
  confidence      Decimal  @default(0) @db.Decimal(5, 4) // 0.0 to 1.0
  wordIndex       Int      // 문장 내 단어 순서 (0부터 시작)
  createdAt       DateTime @default(now())

  segment         TranscriptionSegment @relation(fields: [segmentId], references: [id], onDelete: Cascade)

  @@index([segmentId, wordIndex])
  @@index([segmentId, startTime])
}
